<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->

# mwse

The mwse library provides methods for interacting with MWSE itself, rather than direct TES3 objects.

## Properties

### `mwse.buildDate`

A numerical representation of the date that version of MWSE currently being used was built on.

Formatted as YYYYMMDD.

**Returns**:

* `result` (number)

??? example "Example: Check if the user has minimal required MWSE build installed."

	```lua
	-- Ensure we have the features we need.
	if (mwse.buildDate == nil or mwse.buildDate < 20210817) then
		mwse.log("[Example] Build date of %s does not meet minimum build date of 20210817.", mwse.buildDate)
		return
	end

	```

***

### `mwse.buildNumber`

Equal to the `APPVEYOR_BUILD_NUMBER` in builds by AppVeyor. Equal to `UINT_MAX` in regular builds.

**Returns**:

* `result` (integer)

***

### `mwse.gameTimers`

The mwseTimerController responsible for game-type timers.

**Returns**:

* `result` ([mwseTimerController](../../types/mwseTimerController))

***

### `mwse.realTimers`

The mwseTimerController responsible for real-type timers.

**Returns**:

* `result` ([mwseTimerController](../../types/mwseTimerController))

***

### `mwse.simulateTimers`

The mwseTimerController responsible for simulate-type timers.

**Returns**:

* `result` ([mwseTimerController](../../types/mwseTimerController))

***

### `mwse.version`

A numerical representation of the release version of MWSE currently being used.

Formatted as AAABBBCCC, where A is the major version, BBB is the minor version, and CCC is the patch version. BBB and CCC are forward-padded.

It is usually better to use `mwse.buildDate` instead.

**Returns**:

* `result` (integer)

***

## Functions

### `mwse.breakpoint`

Prints "[MWSE] Hit breakpoint: ", with the provided `message` string appended, to the `mwse.log` file. This function is meant for debugging purposes.

```lua
mwse.breakpoint(message)
```

**Parameters**:

* `message` (string): *Optional*. Provides a way to mark in the log which breakpoint was reached.

***

### `mwse.clearScriptOverride`

Configures MWSE to no longer execute a lua function instead when a script would run. This undoes the work of `mwse.overrideScript`.

```lua
local result = mwse.clearScriptOverride(scriptId)
```

**Parameters**:

* `scriptId` (string)

**Returns**:

* `result` (boolean)

***

### `mwse.getCurrentMorrowindScriptState`

This function returns information on the current mwscript execution state.

```lua
local script, reference = mwse.getCurrentMorrowindScriptState()
```

**Returns**:

* `script` ([tes3script](../../types/tes3script), nil): The currently executing mwscript script, or nil if none is presently being executed.
* `reference` ([tes3reference](../../types/tes3reference), nil): The currently executing mwscript script's associated reference. This will be nil for global scripts, or nil if no script is presently being executed.

***

### `mwse.getVersion`

Equivalent to mwse.version.

```lua
local result = mwse.getVersion()
```

**Returns**:

* `result` (integer)

***

### `mwse.getVirtualMemoryUsage`

Returns the amount of memory used, in bytes.

```lua
local result = mwse.getVirtualMemoryUsage()
```

**Returns**:

* `result` (number)

***

### `mwse.iconv`

Converts the provided string in UTF8 encoding to Morrowind's codepage base encoding.

```lua
local converted = mwse.iconv(languageCode, utf8string)
```

**Parameters**:

* `languageCode` (integer): Determines the language (and appropriate encoding) to use. Maps to values in [`tes3.languageCode`](https://mwse.github.io/MWSE/references/language-codes/) table.
* `utf8string` (string): The string to convert

**Returns**:

* `converted` (string)

***

### `mwse.loadConfig`

Loads a config table from Data Files\\MWSE\\config\\{fileName}.json.
	
If the default values table is passed, empty keys in the config will be filled in using its values. Additionally, if no file exists, the function will return the default table.

```lua
local result = mwse.loadConfig(fileName, defaults)
```

**Parameters**:

* `fileName` (string): The non-extensioned name of the config file.
* `defaults` (table): *Optional*. A table of default values.

**Returns**:

* `result` (table)

***

### `mwse.loadTranslations`

Loads translations from the i18n folder for a given mod. This is locale-aware, using the result from `tes3.getLanguage()`. See the [mod translations guide](https://mwse.github.io/MWSE/guides/mod-translations/) for more information.

```lua
local i18n = mwse.loadTranslations(mod)
```

**Parameters**:

* `mod` (string): Name of the folder that your main.lua mod can be found in.

**Returns**:

* `i18n` (function): The callable translation results.

***

### `mwse.log`

This function writes information to the mwse.log file in the user's installation directory.

The message accepts formatting and additional parameters matching string.format's usage.

```lua
mwse.log(message, formatValues)
```

**Parameters**:

* `message` (string)
* `formatValues` (variadic): *Optional*.

***

### `mwse.longToString`

Converts a TES3 object type (e.g. from tes3.objectType) into an uppercase, 4-character string.

```lua
local result = mwse.longToString(type)
```

**Parameters**:

* `type` (number)

**Returns**:

* `result` (string)

***

### `mwse.overrideScript`

Configures MWSE to execute a given function instead when a script would run.

In most cases its intended to stop the execution of the original mwscript script. You can do so in the callback function by calling `mwscript.stopScript()`.

```lua
local result = mwse.overrideScript(scriptId, callback)
```

**Parameters**:

* `scriptId` (string)
* `callback` (function)

**Returns**:

* `result` (boolean)

??? example "Example: Here is an example of the most common use case for this function."

	```lua
	-- In this example, the vanilla "RaceCheck" script is overridden
	-- with our own raceCheck() function that does the same thing.
	
	local raceCheckScriptID = "RaceCheck"
	
	local function raceCheck()
		-- This is almost always the desired behavior,
		-- since we are overriding the script.
		mwscript.stopScript({ script = raceCheckScriptID })
	
		local pcRaceID = tes3.player.object.race.id:lower()
		local PCRace = tes3.findGlobal("PCRace")
	
		if pcRaceID == "argonian" then
			PCRace.value = 1
		elseif pcRaceID == "breton" then
			PCRace.value = 2
		elseif pcRaceID == "dark elf" then
			PCRace.value = 3
		elseif pcRaceID == "high elf" then
			PCRace.value = 4
		elseif pcRaceID == "imperial" then
			PCRace.value = 5
		elseif pcRaceID == "khajiit" then
			PCRace.value = 6
		elseif pcRaceID == "nord" then
			PCRace.value = 7
		elseif pcRaceID == "orc" then
			PCRace.value = 8
		elseif pcRaceID == "redguard" then
			PCRace.value = 9
		elseif pcRaceID == "wood elf" then
			PCRace.value = 10
		end
	end
	
	-- Script overrides can be queued when initialited event triggers.
	event.register(tes3.event.initialized, function()
		mwse.overrideScript(raceCheckScriptID, raceCheck)
	end)

	```

***

### `mwse.saveConfig`

Saves a config table to Data Files\\MWSE\\config\\{fileName}.json.

```lua
local result = mwse.saveConfig(fileName, object, config)
```

**Parameters**:

* `fileName` (string)
* `object` (unknown)
* `config` (table): *Optional*.

**Returns**:

* `result` (table)

***

### `mwse.stringToLong`

Converts an uppercase, 4-character string into a TES3 object type.

```lua
local result = mwse.stringToLong(tag)
```

**Parameters**:

* `tag` (string)

**Returns**:

* `result` (number)

***

### `mwse.virtualKeyPressed`

Determines whether a key is pressed. A wrapper for `GetAsyncKeyState` function in Win32 API.

```lua
local result = mwse.virtualKeyPressed(VK_key)
```

**Parameters**:

* `VK_key` (integer)

**Returns**:

* `result` (boolean)

***

