# mwseTimerCallbackData
<div class="search_terms" style="display: none">mwsetimercallbackdata</div>

<!---
	This file is autogenerated. Do not edit this file manually. Your changes will be ignored.
	More information: https://github.com/MWSE/MWSE/tree/master/docs
-->

The data passed to callback function registered to a mwseTimer.

## Properties

### `timer`
<div class="search_terms" style="display: none">timer</div>

*Read-only*. Access to the timer that manages for this callback function. Can be used to cancel the timer inside the callback function or to access the data table stored on the timer.

**Returns**:

* `result` ([mwseTimer](../../types/mwseTimer))

??? example "Example: Persistent timer"

	Examine how the data table stored on timer can be accessed from the callback function.

	```lua
	---@param e mwseTimerCallbackData
	local function showMessage(e)
		local timer = e.timer
		local data = timer.data
		local currentTimestamp = tes3.getSimulationTimestamp()
	
		-- We are sure that the timer.data ~= nil since we
		-- created that table in timer.start function.
		-- So, lets disable the warnings for a bit.
		---@diagnostic disable:need-check-nil
		tes3.messageBox(data.message:format(
			data.startTimestamp,
			data.lastIterationTimestamp,
			currentTimestamp
		))
		---@diagnostic enable:need-check-nil
	
		-- Save this to the data table on the timer
		data.lastIterationTimestamp = currentTimestamp
	end
	
	timer.register("testExample:OneDayTimer", showMessage)
	
	timer.start({
		type = timer.game,
		persist = true,
		iterations = -1,
		duration = 24,
		-- Notice that the callback isn't a function, but
		-- a string passed to the timer.register function
		callback = "testExample:OneDayTimer",
		data = {
			startTimestamp = tes3.getSimulationTimestamp(),
			lastIterationTimestamp = tes3.getSimulationTimestamp(),
			message = [[One day later...
	timer's starting timestamp %s
	the timestamp of last iteration %s
	current timestamp %s
	]]
		}
	})

	```

